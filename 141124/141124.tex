\documentclass[12pt,a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{graphics}
\usepackage{ bbold }

\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\renewcommand{\C}{\mathbb{C}}
\renewcommand{\le}{\leqslant}
\theoremstyle{plain}
\newtheorem{thm}{Теорема}
\newtheorem{lem}{Лемма}

\DeclareMathOperator{\E}{\mathbb{E}}
\DeclareMathOperator{\PP}{\mathbb{P}}
\newcommand{\prob}[1]{\PP\{#1\}}
\newcommand{\ind}[1]{\mathbb{1}_{\{#1\}}}




\begin{document}

\section{Суффиксное дерево}

Рассмотрим бор, в который добавили все суффиксы строки.
Эта структура содержит в себе всю информацию о подстроках и является мощным
инструментом. Однако имеет размер $O(n^2)$.

Хочется ее как-то сжать. Для этого есть два основных направления.
\begin{itemize}
\item Можно заметить, что в нем $O(n)$ вершин у которых больше 1 сына и сжать пути из таких вершин в одно ребро
\item Можно заметить, что у многих вершин поддерево устроено одинаково. Такие вершины можно объединить в одну.
\end{itemize}

Оба подхода приводят к структурам размера $O(n)$, строящися за линейное время. Мы рассмотрим второй подход.

\section{Конечные автоматы}

Конечным детерминированным автоматом назвается пятерка $(S, s, \Sigma, \delta, F)$, где 
\begin{itemize}
\item $S$ "--- конечное множество состояний.
\item $s \in S$ "--- начальное состояние.
\item $\Sigma$ "--- конечный алфавит
\item $\delta: S \times \Sigma \rightarrow S$ "--- функция переходов
\item $F \subset S$ "--- множество терминальных состояний.
\end{itemize}

О таком автомате можно думать как об ориентированном графе, на каждом ребре
которого написано по букве, причем их каждой вершины выходит не более одного ребра с такой буквой.

Будем говорить, что автомат принемает строку, если из начального состояния можно сделать последовательные переходы 
по буквам строки и попасть в терминальное состояние.

\section{Суффиксный автомат}

Суффиксным автоматом называется минимальный конечный детерминированный автомат, который
принемает все суффиксы строки и только их.

Заметим, что в таком автомате нет циклов.

\section{Правый контекст}

{\it Правым контекстом} строки $u$ относительно строки $s$ (обозначаем $R_s(u)$) называется множество строк $v$, таких, что
$uv$ является суффиксом $s$.

Вершине автомата должен соответствовать в точности класс эквивалентности строк по правому контексту.
Если в одну вершину автомата приведут строки с разным правым контекстом, то автомат некорректен,
если несколько вершин автомата соотвествуют строкам с одинаковым правым контекстом, то не минимален.

\section{Свойства правых контекстов}
          
\begin{thm}
Пусть $u$ "--- суффикс $v$. Тогда $R_s(v) \subset R_s(u)$. 
\end{thm}

\begin{thm}
Пусть $R_s(u) \neq \varnothing, R_s(v) \neq \varnothing$, $|u| \le |v|$, при этом $R_s(u) \cap R_s(v) \neq \varnothing$. Тогда
$R(v) \subset R(u)$, причем $u$ "--- суффикс $v$.
\end{thm}

\begin{thm}
Класс эквивалентности по равенству правых контекстов представляет собой
несколько самых длинных суффиксов некоторой строки.
\end{thm}

Для непустой строки $u$ определим $Suff(u)$ как самый длинный суффикс $u$, для которого 
правый контекст шире.

\section{Изменение правых контекстов от добавления символа к строке $s$}

\begin{thm}
При приписывании новой буквы к строке $s$
\begin{itemize}
\item К всем элементам правого контекста приписывается эта буква.
\item Появляется новый класс эквивалентности с правым контекстом $\varepsilon$
\item К правому контексту некоторых строк добавляется $\varepsilon$.
\end{itemize}
\end{thm}

Таким образом каждый класс, может разбиться не более чем на 2.
На самом деле разобьется на 2 только один класс.

\section{Изменение переходов между классами эквивалентности}

\begin{thm}
Пусть $\varepsilon \notin R(u)$. Тогда переходы из этого класса, кроме перехода по новой не поменялись.
Ни один из классов, в которые ведут переходы, кроме перехода по новой букве, не раздвоился.
Если переход по новой букве раздвоился, то теперь переход ведет в половину без $\varepsilon$.
\end{thm}

\begin{thm}
Пусть $\varepsilon \in R(u)$, при этом их этого класса эквивалентности нет перехода по добавленной букве,
тогда переходы из этого класса не поменялись. Ни один из классов, в которые они ведут не раздвоился,
но добавился новый переход по добавленной букве в класс эквивалентности с правым контекстом $\{\varepsilon\}$
\end{thm}

\begin{thm}
Пусть $\varepsilon \in R(u)$, при этом их этого класса эквивалентности есть переход по добавленной букве,
тогда переходы из этого класса, кроме перехода по новой не поменялись. Ни один из классов, в которые ведут переходы,
кроме перехода по новой букве, не раздвоился. Если переход по новой букве раздвоился, то теперь переход ведет в половину c $\varepsilon$.
\end{thm}

Для того, чтобы класс раздвоился, необходимо чтобы у части строк появился $\varepsilon$ в правом контексте,
а у части нет. Но тогда, может раздвоиться только самый большого класса. Так как у остальных
$\varepsilon$ добавиться ко всем вершинам.

\section{Алгоритм построения}

Будем для каждой вершины хранить переходы,
суффиксную ссылку, а также длину самой большой строки в классе эквивалентности.

Будем добавлять буквы по одной

\begin{itemize}
\item Создаем новую вершину, которой соответсвует класс $\{\varepsilon\}$.
\item Идем по суффиксным ссылкам от новой вершины предыдущего шага, пока не упремся в корень, или не найдем переход по букве.
По пути добавляем переходы в новую вершину.
\item Если дошли до корня "--- он суффиксная ссылка новой вершины, шаг закончен
\item Если нет, то надо понять раздвоится ли вершина. Если нет, то она суффиксная ссылка новой вершины, и шаг закончен.
\item Если раздвоится, то надо склонировать вершины, пойти дальше вдоль суффиксного пути, и все переходы в старую вершину, перенаправить
в клона. При этом клон становится суффиксной ссылкой и новой вершины, и вершины с которой он склонирован.
\end{itemize}

Для понимания раздвоится ли вершина, будкм хранить самую длинную строку в классе эквивалентности.
Вершина раздвоится если самая длинная строка в ней, более чем на 1 длинее самой длинной там, откуда переход.

\section{Доказательство линейности}

Следим за $Len(Suff(Suff(new)))$. Так получается время работы $O(n*\Sigma)$.

\section{Примеры задач}

\begin{enumerate}
\item Добавлять символ, проверять подстрока ли
\item Идти строкой и поддерживать самый большой суффикс, который является подстрокой строки
\item Найти количество подстрок               
\item Найти количество подстрок у всех префиксов
\item Найти подстроку с максимальным количеством вхождений, среди таких самую длинную.
\end{enumerate}

\end{document}                                
