1. Splay Tree.
1a. Left Rotate, Right Rotate, PreSplay.
1b. zig, zig-zag, zig-zig. Splay  (10 минут)
1с. Access = Find + Splay, Merge = Find + Splay, Split = Find + Splay!
1d. Есть Split, Merge -> получили дерево по неявному ключу. 
1e. Реализация. Big Rotate = 2*Rotate (5 минут)
1e. Амортизация потенциальной функции.
1f. Вес, размер,ранг. (5 минут)
1g. Access Lemma, Ballance theorem, Static optimality theorem. (15 минут)
== 35 минут.

2. Euler Tour Tree
2a. Эйлеров обход дерева. 
2b. Поддерево = отрезок эйлерова обхода.
2с. Положим эйлеров обход в дерево. PROFIT!
2d. Пример. Бамбуки и циклы.
2e. Реализация. Чем ребра лучше вершин. Привязка ребра к вершине дерева, хранение обратного ребра.
    Хранение предка в декартовом дереве, подсчет номера по указателю.

== 60 минут

Перерыв (5 минут)

3. Heavy Light Decomposition
3a. Разбиение дерева на пути.
3b. На пути не более log легких и нет тяжелых.
3с. Построим внутренюю структуру. (10 минут)
3d. Реализация. Каждый знает указатель на свою структуру, структура умеет преобразовывать во внутренний индекс сама. (5 минут)
3e. Пример. += на пути и минимум.
            
== 85 минут

4. LCT
4a. Нельзя построить зарание, значит будем перестраивать.
4b. Expose. (15 минут)
4с. Оценка log*Struct.
4d. Реализация. (Все через MakeRoot)
== Примерно пара.
4e. Оценка log для Splay. (15 минут)

== 135 минут

5. Dinamic Connectivity Problem
5a. Постановка задачи. Online - сложно, живем в Offline.
5b. Корневая на запросах.
5с. Живые и неживые ребра. Сжали компоненты. Profit. (15 минут).
5d. Добавить и удалить == Добавить на отрезке.
5e. Снм с откатом. Оставим только rank. (10 минут)

== 160 минут
== Перерыв.

6. Dinamic 2-Connectivity Problem
6a. Постановка задачи. Живем еще больше в Offline.
6b. Корневая на запросах.
6c. Сжали компоненты двусвязности. Почему мало?
6e. Сжали неинтересные ребра, посчитали точно мосты. (20 минут)
6f. Дерево отрезков. Применяем все те же идеи. (20 минут)

==220 минут.


                                         